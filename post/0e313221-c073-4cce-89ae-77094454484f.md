## 문제

### 설명

수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
- completion의 길이는 participant의 길이보다 1 작습니다.
- 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
- 참가자 중에는 동명이인이 있을 수 있습니다.

### 입출력 예

| participant | completion | return |
| ----------- | ---------- | ------ |
| ['leo', 'kiki', 'eden'] | ['eden', 'kiki'] | 'leo' |
| ['marina', 'josipa', 'nikola', 'vinko', 'filipa'] | ['josipa', 'filipa', 'marina', 'nikola'] | 'vinko' |
| ['mislav', 'stanko', 'mislav', 'ana'] | ['stanko', 'ana', 'mislav'] | 'mislav' |

### 입출력 예 설명

예제 #1

- `leo`는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

예제 #2

- `vinko`는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

예제 #3

- `mislav`는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.

## 풀이

```javascript
function solution(participant, completion) {
    let notCompletion = ''
    let sortParticipant = participant.sort()
    let sortCompletion = completion.sort()

    for (let index in sortParticipant) {
        if (sortParticipant[index] !== sortCompletion[index]) {
            notCompletion = sortParticipant[index]

            break
        }
    }

    return notCompletion
}
```

## 느낀점

단순히 문제를 푸는 것을 중심으로 풀면 어렵지 않았습니다. 당연히 금방 풀었고, 모든 케이스에서 통과를 받았습니다. 그런데 문제는 효율성을 하나도 통과를 하지 못했습니다. 그 후로 단순히 문제만 풀면 안되는 것을 알았습니다.

hashMap을 사용하면 된다는 말도 들었고, 여러가지 방법도 알아봤습니다. 하지만 어떤 방법을 사용하던 해당 문제는 O(n^2)을 타는 순간 틀린 것을 알았습니다. 그래서 이것을 O(n)으로 풀기로 가닥을 잡았습니다.

우선 두개의 배열의 상태를 생각했습니다. 중복되는 값도 있으며 `completion`이 `participant`보다 1개 적으며, 무작위 나열을 중점적으로 봤습니다. 그 1개를 찾기 위해 비교를 하려면 O(n^2)말고는 방법이 없는 것 같았습니다. 그래서 위 3가지 사항을 정리하여 조건을 최소화 해보고자 했습니다.

- 중복되는 값이 있다. → 중복을 제거하면 다른 1개의 값을 찾을 수 없다. (X)
- 값이 없는 1개를 찾는다. → 이것을 찾는 것이 문제이다. (X)
- 무작위 나열이다. → 찾고자 하는 값과 별개이며, 제거해도 문제에 영향이 없다. (O)

이렇게 정리하여 두개의 배열을 무작위에서 알파벳 순으로 정렬을 하였고, 자동적으로 두 배열의 차이는 한번의 반복으로 찾을 수 있게 되었습니다. 같은 카운트로 반복을 돌리다 값이 다른 카운트에 반복을 종료하면 해당 값이 다른 1개의 값이 될 수 있게 되었습니다.

이렇게 O(n^2)를 O(3n)으로 만들어 연산하는 횟수를 줄일 수 있었습니다. 당연히 효율성도 모두 통과하였습니다.

처음 계속 방법을 바꾸어 가며 제출을 할 때에 효율성이 안나와 `JS는 이것을 통과할 수 없는 것인가?` 까지 생각을 했습니다. 그래서 단순히 반복과 조건을 위주로 생각을 해보았습니다. 어떤 언어든 이 두 가지는 가지고 갈 수 밖에 없기에 순수하게 두 가지로 풀면 다른 연산은 들어가지 않을 것이라 생각을 했습니다.
